{"version":3,"sources":["backbone.hexer.js"],"names":["root","factory","define","amd","_","Backbone","$","exports","Hexer","require","e","jQuery","Zepto","ender","this","parseFloatIfString","value","isString","parseFloat","replace","oppositePosition","position","getHexesAtDistance","distance","hexList","last","first","each","hex","index","isNull","options","slice","HexGridView","View","extend","tagName","className","defaults","depth","color","size","spacing","center","x","y","events","hexes","animateTimeout","initialize","unit","bindAll","createHexViews","render","i","fillDepth","console","log","addHex","allEdgeHexes","addAdjacentHexes","bind","newHex","Hex","push","$el","append","addAdjacentHex","originHex","hexParams","angle","Math","PI","scale","cos","sin","originPosition","neighbors","addNeighbor","prevPosition","nextPosition","has","startPosition","count","isUndefined","content","partial","animate","params","animateFunction","order","delay","animateHelper","length","setTimeout","isFunction","cssProps","transform","webkitTransform","width","sqrt","height","background","css","html","call","exchange","VERSION"],"mappings":"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","file":"backbone.hexer.min.js","sourcesContent":["// backbone.hexer.js 0.1\n// (c) 2015 Lindsay Gaines\n\n// backbone.hexer may be freely distributed under the MIT license.\n// For all details and documentation:\n// http://github.com/aethr/backbone.hexer\n\n(function(root, factory) {\n  // Set up depending on the environment. Start with AMD.\n  if (typeof define === 'function' && define.amd) {\n    define(['underscore', 'backbone', 'jquery', 'exports'], function(_, Backbone, $, exports) {\n      // Export global even in AMD case in case this script is loaded with\n      // others that may still expect a global Backbone.\n      Backbone.Hexer = factory(root, exports, _, Backbone, $);\n    });\n\n  // Next for Node.js or CommonJS. jQuery may not be needed as a module.\n  } else if (typeof exports !== 'undefined') {\n    var _ = require('underscore'), Backbone = require('backbone'), $;\n    try { $ = require('jquery'); } catch(e) {}\n\n    factory(root, exports, _, Backbone, $);\n\n  // Finally, as a browser global.\n  } else {\n    root.Backbone.Hexer = factory(root, {}, root._, root.Backbone, (root.jQuery || root.Zepto || root.ender || root.$));\n  }\n}(this, function(root, Hexer, _, Backbone, $) {\n\n  // a Hexer is a Backbone View\n  Hexer = Backbone.Hexer = Backbone.HexGridView = Backbone.View.extend({\n\n    tagName: \"div\",\n    className: \"bbh-container\",\n\n    defaults: {\n      depth: 2,\n      color: '#999999',\n      size: '6em',\n      spacing: '0.5em',\n      center: {x: 0, y: 0}\n    },\n\n    events: {},\n\n    hexes: [],\n\n    animateTimeout: null,\n\n    initialize: function(options) {\n      // Default options\n      this.options = _.extend({}, this.defaults, options);\n\n      // Split convenient notations (ie '5em') into their value and unit\n      this.options.unit     = this.options.size.replace( /^\\d+/g, '');\n      this.options.size     = parseFloatIfString(this.options.size);\n      this.options.spacing  = parseFloatIfString(this.options.spacing);\n      this.options.center.x = parseFloatIfString(this.options.center.x);\n      this.options.center.y = parseFloatIfString(this.options.center.y);\n\n      _.bindAll(this, 'addAdjacentHexes');\n\n      // Create all the Hexes\n      this.createHexViews();\n    },\n\n    render: function() {\n      // Allow each hex to re-render if necessary\n      _.each(this.hexes, function (hex, i) {\n        hex.render();\n      });\n      return this;\n    },\n\n    /**\n     * Create the individual Hexes that will comrprise the grid.\n     */\n    createHexViews: function() {\n      var fillDepth = (this.options.depth == 'fill') ? 10 : this.options.depth;\n\n      for (var i = 0; i < fillDepth; i++) {\n        switch (i) {\n          // No Hexes have been created yet, make the first\n          case 0:\n              console.log('0');\n            this.addHex({\n              distance: 0,\n              x: this.options.center.x,\n              y: this.options.center.y\n            });\n            break;\n\n          // Only one Hex is present, ring it with 6 more\n          //case 1:\n          //  this.addAdjacentHexes(this.hexes[0], 0, 6);\n          //  this.addAdjacentHexes(this.hexes[1], 0, 6);\n          //  break;\n\n          default:\n            // This is complicated!\n            var allEdgeHexes = getHexesAtDistance(i - 1, this.hexes);\n            _.each(allEdgeHexes, function (hex, index) {\n              this.addAdjacentHexes(hex, 0, 6);\n            }.bind(this));\n            break;\n        }\n      }\n    },\n\n    /**\n     * Helper function to create a single Hex with the specified options, and\n     * add its el to the DOM.\n     *\n     * @param options\n     *   Parameters to pass to the constructor of the new Hex\n     * @returns {Hex}\n     */\n    addHex: function(options) {\n      options = _.extend({\n          size: this.options.size + this.options.unit,\n          color: this.options.color\n      }, options);\n      var newHex = new Hex(options);\n      this.hexes.push(newHex);\n      this.$el.append(newHex.$el);\n\n      return newHex;\n    },\n\n    /**\n     * Add a single adjacent hex to the origin hex, at one of the edges\n     * specified by the position.\n     *\n     * @param originHex\n     *   The Hex that will have new Hexes added around its edges.\n     * @param position\n     *   The position of the edge where the new hex should be drawn\n     *    0\n     * 5 / \\ 1\n     * 4 \\_/ 2\n     *    3\n     * @param hexParams\n     *   The options to be passed to the new Hex\n     */\n    addAdjacentHex: function (originHex, position, hexParams) {\n      // Calculate the angle between the originHex and the new adjacent Hex\n      var angle = (position == 0) ? 0 : (2.0 * Math.PI / 6) * position,\n\n          // Distance of the new Hex from the originHex\n          scale = this.options.size + this.options.spacing,\n\n          // Position of the new Hex\n          x = originHex.options.x + (Math.cos(angle) * scale),\n          y = originHex.options.y + (Math.sin(angle) * scale),\n\n          // Store the distance from the original Hex\n          distance = originHex.options.distance + 1,\n\n          // Keep a reference to the originHex\n          originPosition = oppositePosition(position),\n          neighbors = {};\n\n      // Since they are adjacent, the originHex will occupy the opposite edge\n      neighbors[originPosition] = originHex;\n\n      // Add a new Hex with the supplied parameters, at the new coordinates\n      var newHex = this.addHex(_.extend({\n        x: x,\n        y: y,\n        distance: distance,\n        neighbors: neighbors\n      }, hexParams));\n\n      // Store a reference to the originHex's new neighbor\n      originHex.addNeighbor(position, newHex, true);\n\n      // If the originHex has neighbors adjacent to the new Hex, pass the\n      // references so the Hex grid has a more complete set of relationships\n      var prevPosition = (position - 1 >= 0) ? position - 1 : position + 5,\n          nextPosition = (position + 1 < 6)  ? position + 1 : position - 5;\n      if (_.has(originHex.options.neighbors, prevPosition)) {\n        newHex.addNeighbor(prevPosition - 1, originHex.options.neighbors[prevPosition], true);\n      }\n      if (_.has(originHex.options.neighbors, nextPosition)) {\n        newHex.addNeighbor(nextPosition + 1, originHex.options.neighbors[nextPosition], true);\n      }\n    },\n\n    /**\n     * Add new Hexes adjacent to the originHex, starting at the specified\n     * startPosition.  Any positions that are already filled with a Hex will\n     * be skipped.\n     *\n     * @param originHex\n     *   The Hex to add adjacent Hexes to.\n     * @param startPosition\n     *   The position of the edge where the first Hex should be added.\n     * @param count\n     *   The number of Hexes to be added.\n     */\n    addAdjacentHexes: function(originHex, startPosition, count) {\n      // Reset values back within legal bounds\n      if (count > 6)\n        count = 6;\n      if (startPosition > 5) {\n        startPosition -= 6;\n      }\n      // Add a new Hex for each edge until we reach the supplied count\n      for (var i = startPosition; i < startPosition + count; i++) {\n        // Don't try to add a new Hex where there is one already\n        if (!_.isUndefined(originHex.options.neighbors[i]) && !_.isNull(originHex.options.neighbors[i])) {\n          continue;\n        }\n\n        // Add the new Hex\n        this.addAdjacentHex(originHex, i, {\n          // Just an example, print the hex number inside each hex\n          content: _.partial(function(i) { return i; }, i)\n        });\n      }\n    },\n\n    /**\n     * A function that allows an animation to be run across a set of Hexes.\n     *\n     * @param options\n     *   An object which specifies how to animate the Hexes.  Valid keys are:\n     *   order: an array of Hexes, in the order you want to animate them.\n     *   animateFunction: a function with a single argument for a Hex.  This\n     *     function will be called once on each Hex provided in order.\n     *   delay: the number of ms to delay in between animating each Hex.\n     */\n    animate: function(options) {\n      // Set some sane defaults for the animation\n      var params = _.extend({\n        animateFunction: function(hex) { /* Do something! */ },\n        order: this.hexes,\n        delay: 50\n      }, options);\n\n      // Create a helper function that will help us execute a single animation\n      // and then set a timeout for the next animation\n      var animateHelper = function (hexList, index, animateFunction, delay) {\n        // Execute the animation on the current Hex\n        animateFunction(hexList[index]);\n\n        // If we haven't gotten to the end of the list, set a timer for the\n        // next animation to occur\n        if (index + 1 < hexList.length) {\n          // Store a reference to the timeout in case we want to end early\n          this.animateTimeout = setTimeout(function() {\n            animateHelper(hexList, index + 1, animateFunction, delay);\n          }, params.delay);\n        }\n      }\n\n      // Kick off the first animation straight away\n      animateHelper(params.order, 0, params.animateFunction, params.delay);\n    }\n\n  });\n\n  // a Hexer is a Backbone View\n  var Hex = Backbone.View.extend({\n    tagName: \"div\",\n    className: \"bbh-hex\",\n\n    defaults: {\n      x: 0, y: 0,\n      size: '3em',\n      color: '#999999',\n      content: '',\n      neighbors: {}\n    },\n\n    neighbors: {},\n\n    initialize: function(options) {\n      // Default options\n      this.options = _.extend({}, this.defaults, options);\n\n      this.options.unit = this.options.size.replace( /^\\d+/g, '');\n      this.options.size = parseFloatIfString(this.options.size);\n\n      // Allow content to be defined by a function, simply replace the\n      // default function, which just returns this.options.content\n      if (_.isFunction(this.options.content)) {\n        this.content = this.options.content;\n      }\n    },\n\n    render: function() {\n      var cssProps = {\n        transform: 'translateX(' + this.options.x + this.options.unit + ') translateY(' + this.options.y + this.options.unit + ')',\n        webkitTransform: 'translateX(' + this.options.x + this.options.unit + ' translateY(' + this.options.y + this.options.unit + ')',\n        width:  (Math.sqrt(3)/2 * this.options.size) + this.options.unit, // width is smaller than height\n        height: this.options.size + this.options.unit\n      }\n\n      if (_.isNull(this.options.color)) {\n        cssProps.background = this.options.color;\n      }\n\n      // Set the css properties of the Hex to display in the right place\n      this.$el.css(cssProps);\n\n      // Set the inner content of the Hex if available\n      this.$el.html('<div class=\"content\"><span>' + this.content.call(this) + '</span></div>');\n\n      return this;\n    },\n\n    /**\n     * Default content function, just returns the content string.\n     * @returns string\n     */\n    content: function() {\n      return this.options.content;\n    },\n\n    /**\n     * Add a reference to a neighboring Hex.\n     * @param position\n     *   The position of the neighbor.\n     * @param hex\n     *   The reference to the neighbor Hex.\n     * @param exchange\n     *   If true, a reference to this Hex will be passed to the neighboring Hex.\n     */\n    addNeighbor: function(position, hex, exchange) {\n      exchange = (!_.isUndefined(exchange)) ? exchange : false;\n\n      // Normalise position\n      position = (position > 5) ? position - 6 : position;\n      position = (position < 0) ? position + 6 : position;\n\n      // Store a reference at the specified position to the new neighbor\n      this.options.neighbors[position] = hex;\n\n      // If Hexes are exchanging neighbors, tell the neighbor to store a\n      // reference to this Hex in the opposite position\n      if (exchange === true) {\n        // For the neighbor Hex, this will occupy the opposite position\n        hex.addNeighbor(oppositePosition(position), this, false);\n      }\n    }\n\n  });\n\n\n  /**\n   * Privately scoped helper functions\n   */\n\n  // Remove CSS units (eg, 'px') and return the numeric value as a float\n  function parseFloatIfString(value) {\n    if (_.isString(value)) {\n      return parseFloat(value.replace( /\\D+$/g, ''));\n    }\n    else {\n      return value * 1.0;\n    }\n  }\n\n  // Gets the position on the opposite side of a Hex\n  function oppositePosition(position) {\n    return (position + 3 > 5) ? position - 3 : position + 3;\n  }\n\n  // This assumes that hexList is ordered by distance.\n  function getHexesAtDistance(distance, hexList) {\n    var first = null,\n        last;\n    _.each(hexList, function (hex, index) {\n      if (_.isNull(first) && hex.options.distance == distance) {\n        first = index;\n      }\n      if (_.isNull(last) && !_.isNull(first) && hex.options.distance > distance) {\n        last = index;\n      }\n    });\n\n    return hexList.slice(first, last);\n  }\n\n  // Current version of the library. Keep in sync with `package.json`.\n  Hexer.VERSION = '0.0.1';\n\n  return Hexer;\n}));"],"sourceRoot":"/source/"}