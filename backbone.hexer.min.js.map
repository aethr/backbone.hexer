{"version":3,"sources":["backbone.hexer.js"],"names":["root","factory","define","amd","_","Backbone","$","exports","Hexer","require","e","jQuery","Zepto","ender","this","parseFloatIfString","value","isString","parseFloat","replace","oppositePosition","position","getHexesAtDistance","distance","hexList","last","first","each","hex","index","isNull","options","slice","HexGridView","View","extend","tagName","className","defaults","depth","color","size","spacing","center","x","y","events","hexes","animateTimeout","initialize","unit","bindAll","$div","document","body","insertBefore","childNodes","createHexViews","render","i","fillDepth","addHex","allEdgeHexes","addAdjacentHexes","bind","newHex","Hex","push","$el","append","addAdjacentHex","originHex","hexParams","angle","Math","PI","scale","cos","sin","originPosition","neighbors","addNeighbor","prevPosition","nextPosition","has","startPosition","count","isUndefined","animate","params","animateFunction","animateQueue","delay","animateHelper","animationTargets","shift","length","setTimeout","clone","content","isFunction","cssProps","clipPath","webkitClipPath","transform","webkitTransform","width","sqrt","height","background","css","html","call","exchange","VERSION"],"mappings":"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","file":"backbone.hexer.min.js","sourcesContent":["// backbone.hexer.js 0.1\n// (c) 2015 Lindsay Gaines\n\n// backbone.hexer may be freely distributed under the MIT license.\n// For all details and documentation:\n// http://github.com/aethr/backbone.hexer\n\n(function(root, factory) {\n  // Set up depending on the environment. Start with AMD.\n  if (typeof define === 'function' && define.amd) {\n    define(['underscore', 'backbone', 'jquery', 'exports'], function(_, Backbone, $, exports) {\n      // Export global even in AMD case in case this script is loaded with\n      // others that may still expect a global Backbone.\n      Backbone.Hexer = factory(root, exports, _, Backbone, $);\n    });\n\n  // Next for Node.js or CommonJS. jQuery may not be needed as a module.\n  } else if (typeof exports !== 'undefined') {\n    var _ = require('underscore'), Backbone = require('backbone'), $;\n    try { $ = require('jquery'); } catch(e) {}\n\n    factory(root, exports, _, Backbone, $);\n\n  // Finally, as a browser global.\n  } else {\n    root.Backbone.Hexer = factory(root, {}, root._, root.Backbone, (root.jQuery || root.Zepto || root.ender || root.$));\n  }\n}(this, function(root, Hexer, _, Backbone, $) {\n\n  // a Hexer is a Backbone View\n  Hexer = Backbone.Hexer = Backbone.HexGridView = Backbone.View.extend({\n\n    tagName: \"div\",\n    className: \"bbh-container\",\n\n    defaults: {\n      depth: 2,\n      color: '#999999',\n      size: '6em',\n      spacing: '0.5em',\n      center: {x: 0, y: 0}\n    },\n\n    events: {},\n\n    hexes: [],\n\n    animateTimeout: null,\n\n    initialize: function(options) {\n      // Default options\n      this.options = _.extend({}, this.defaults, options);\n\n      // Split convenient notations (ie '5em') into their value and unit\n      this.options.unit     = this.options.size.replace( /^\\d+/g, '');\n      if (this.options.unit == '') this.options.unit = 'em'; // Default to em\n      // Parse the numeric values into floats\n      this.options.size     = parseFloatIfString(this.options.size);\n      this.options.spacing  = parseFloatIfString(this.options.spacing);\n      this.options.center.x = parseFloatIfString(this.options.center.x);\n      this.options.center.y = parseFloatIfString(this.options.center.y);\n\n      _.bindAll(this, 'addAdjacentHexes');\n\n      // Add the hex clip svg to the document so it can be used in the\n      // clip-path: url(...); format in firefox\n      // This is a hack so the developer doesm't need to include the svg in\n      // every document\n      var $div = $('<svg width=\"0\" height=\"0\"><defs><clipPath id=\"bbh-hexclip\" clipPathUnits=\"objectBoundingBox\"><polygon points=\"0.5 0 1 0.25 1 0.75 0.5 1 0 0.75 0 0.25\"/></clipPath></defs></svg>');\n      document.body.insertBefore($div[0], document.body.childNodes[0]);\n\n      // Create all the Hexes\n      this.createHexViews();\n    },\n\n    render: function() {\n      // Allow each hex to re-render if necessary\n      _.each(this.hexes, function (hex, i) {\n        hex.render();\n      });\n      return this;\n    },\n\n    /**\n     * Create the individual Hexes that will comrprise the grid.\n     */\n    createHexViews: function() {\n      var fillDepth = (this.options.depth == 'fill') ? 10 : this.options.depth;\n\n      for (var i = 0; i < fillDepth; i++) {\n        switch (i) {\n          // No Hexes have been created yet, make the first\n          case 0:\n            this.addHex({\n              distance: 0,\n              x: this.options.center.x,\n              y: this.options.center.y\n            });\n            break;\n\n          // Find every Hex at the current depth and add Hexes around it!\n          default:\n            // This is complicated!\n            var allEdgeHexes = getHexesAtDistance(i - 1, this.hexes);\n            _.each(allEdgeHexes, function (hex, index) {\n              this.addAdjacentHexes(hex, 0, 6);\n            }.bind(this));\n            break;\n        }\n      }\n    },\n\n    /**\n     * Helper function to create a single Hex with the specified options, and\n     * add its el to the DOM.\n     *\n     * @param options\n     *   Parameters to pass to the constructor of the new Hex\n     * @returns {Hex}\n     */\n    addHex: function(options) {\n      options = _.extend({\n          size: this.options.size + this.options.unit,\n          color: this.options.color\n      }, options);\n      var newHex = new Hex(options);\n      this.hexes.push(newHex);\n      this.$el.append(newHex.$el);\n\n      return newHex;\n    },\n\n    /**\n     * Add a single adjacent hex to the origin hex, at one of the edges\n     * specified by the position.\n     *\n     * @param originHex\n     *   The Hex that will have new Hexes added around its edges.\n     * @param position\n     *   The position of the edge where the new hex should be drawn\n     *    0\n     * 5 / \\ 1\n     * 4 \\_/ 2\n     *    3\n     * @param hexParams\n     *   The options to be passed to the new Hex\n     */\n    addAdjacentHex: function (originHex, position, hexParams) {\n      // Calculate the angle between the originHex and the new adjacent Hex\n      var angle = (position == 0) ? 0 : (2.0 * Math.PI / 6) * position,\n\n          // Distance of the new Hex from the originHex\n          scale = this.options.size + this.options.spacing,\n\n          // Position of the new Hex\n          x = originHex.options.x + (Math.cos(angle) * scale),\n          y = originHex.options.y + (Math.sin(angle) * scale),\n\n          // Store the distance from the original Hex\n          distance = originHex.options.distance + 1,\n\n          // Keep a reference to the originHex\n          originPosition = oppositePosition(position),\n          neighbors = {};\n\n      // Since they are adjacent, the originHex will occupy the opposite edge\n      neighbors[originPosition] = originHex;\n\n      // Add a new Hex with the supplied parameters, at the new coordinates\n      var newHex = this.addHex(_.extend({\n        x: x,\n        y: y,\n        distance: distance,\n        neighbors: neighbors\n      }, hexParams));\n\n      // Store a reference to the originHex's new neighbor\n      originHex.addNeighbor(position, newHex, true);\n\n      // If the originHex has neighbors adjacent to the new Hex, pass the\n      // references so the Hex grid has a more complete set of relationships\n      var prevPosition = (position - 1 >= 0) ? position - 1 : position + 5,\n          nextPosition = (position + 1 < 6)  ? position + 1 : position - 5;\n      if (_.has(originHex.options.neighbors, prevPosition)) {\n        newHex.addNeighbor(prevPosition - 1, originHex.options.neighbors[prevPosition], true);\n      }\n      if (_.has(originHex.options.neighbors, nextPosition)) {\n        newHex.addNeighbor(nextPosition + 1, originHex.options.neighbors[nextPosition], true);\n      }\n    },\n\n    /**\n     * Add new Hexes adjacent to the originHex, starting at the specified\n     * startPosition.  Any positions that are already filled with a Hex will\n     * be skipped.\n     *\n     * @param originHex\n     *   The Hex to add adjacent Hexes to.\n     * @param startPosition\n     *   The position of the edge where the first Hex should be added.\n     * @param count\n     *   The number of Hexes to be added.\n     */\n    addAdjacentHexes: function(originHex, startPosition, count) {\n      // Reset values back within legal bounds\n      if (count > 6)\n        count = 6;\n      if (startPosition > 5) {\n        startPosition -= 6;\n      }\n      // Add a new Hex for each edge until we reach the supplied count\n      for (var i = startPosition; i < startPosition + count; i++) {\n        // Don't try to add a new Hex where there is one already\n        if (!_.isUndefined(originHex.options.neighbors[i]) && !_.isNull(originHex.options.neighbors[i])) {\n          continue;\n        }\n\n        // Add the new Hex\n        this.addAdjacentHex(originHex, i, {\n          // Just an example, print the hex number inside each hex\n//          content: _.partial(function(count) { return count; }, this.hexes.length)\n        });\n      }\n    },\n\n    /**\n     * A function that allows an animation to be run across a set of Hexes.\n     *\n     * @param options\n     *   An object which specifies how to animate the Hexes.  Valid keys are:\n     *   animateQueue: a priority queue (array of arrays) of Hexes, with the\n     *     top-level array determining the order of animation.  All hexes in\n     *     the first\n     *   animateFunction: a function with a single argument for a Hex.  This\n     *     function will be called once on each Hex provided in order.\n     *   delay: the number of ms to delay in between animating each Hex.\n     */\n    animate: function(options) {\n      // Set some sane defaults for the animation\n      var params = _.extend({\n        animateFunction: function(hex) { /* Do something! */ },\n        animateQueue: [this.hexes],\n        delay: 50\n      }, options);\n\n      // Create a helper function that will help us execute a single animation\n      // and then set a timeout for the next animation\n      var animateHelper = function (animateQueue, animateFunction, delay) {\n        // Execute the animation on the current Hex\n        var animationTargets = animateQueue.shift();\n        for (var i = 0; i < animationTargets.length; i++) {\n          animateFunction(animationTargets[i]);\n        }\n\n        // If we haven't gotten to the end of the list, set a timer for the\n        // next animation to occur\n        if (animateQueue.length) {\n          // Store a reference to the timeout in case we want to end early\n          this.animateTimeout = setTimeout(function() {\n            animateHelper(animateQueue, animateFunction, delay);\n          }, params.delay);\n        }\n      }\n\n      // Kick off the first animation straight away\n      animateHelper(_.clone(params.animateQueue), params.animateFunction, params.delay);\n    }\n\n  });\n\n  // a Hexer is a Backbone View\n  var Hex = Backbone.View.extend({\n    tagName: \"div\",\n    className: \"bbh-hex\",\n\n    defaults: {\n      x: 0, y: 0,\n      size: '3em',\n      color: '#999999',\n      content: '',\n      neighbors: {}\n    },\n\n    neighbors: {},\n\n    initialize: function(options) {\n      // Default options\n      this.options = _.extend({}, this.defaults, options);\n\n      this.options.unit = this.options.size.replace( /^\\d+/g, '');\n      this.options.size = parseFloatIfString(this.options.size);\n\n      // Allow content to be defined by a function, simply replace the\n      // default function, which just returns this.options.content\n      if (_.isFunction(this.options.content)) {\n        this.content = this.options.content;\n      }\n    },\n\n    render: function() {\n      var cssProps = {\n        clipPath: \"url(#bbh-hexclip)\",\n        webkitClipPath: \"url(#bbh-hexclip)\",\n        transform: 'translateX(' + this.options.x + this.options.unit + ') translateY(' + this.options.y + this.options.unit + ')',\n        webkitTransform: 'translateX(' + this.options.x + this.options.unit + ' translateY(' + this.options.y + this.options.unit + ')',\n        width:  (Math.sqrt(3)/2 * this.options.size) + this.options.unit, // width is smaller than height\n        height: this.options.size + this.options.unit\n      }\n\n      if (_.isNull(this.options.color)) {\n        cssProps.background = this.options.color;\n      }\n\n      // Set the css properties of the Hex to display in the right place\n      this.$el.css(cssProps);\n\n      // Set the inner content of the Hex if available\n      this.$el.html('<div class=\"content\"><span>' + this.content.call(this) + '</span></div>');\n\n      return this;\n    },\n\n    /**\n     * Default content function, just returns the content string.\n     * @returns string\n     */\n    content: function() {\n      return this.options.content;\n    },\n\n    /**\n     * Add a reference to a neighboring Hex.\n     * @param position\n     *   The position of the neighbor.\n     * @param hex\n     *   The reference to the neighbor Hex.\n     * @param exchange\n     *   If true, a reference to this Hex will be passed to the neighboring Hex.\n     */\n    addNeighbor: function(position, hex, exchange) {\n      exchange = (!_.isUndefined(exchange)) ? exchange : false;\n\n      // Normalise position\n      position = (position > 5) ? position - 6 : position;\n      position = (position < 0) ? position + 6 : position;\n\n      // Store a reference at the specified position to the new neighbor\n      this.options.neighbors[position] = hex;\n\n      // If Hexes are exchanging neighbors, tell the neighbor to store a\n      // reference to this Hex in the opposite position\n      if (exchange === true) {\n        // For the neighbor Hex, this will occupy the opposite position\n        hex.addNeighbor(oppositePosition(position), this, false);\n      }\n    }\n\n  });\n\n\n  /**\n   * Privately scoped helper functions\n   */\n\n  // Remove CSS units (eg, 'px') and return the numeric value as a float\n  function parseFloatIfString(value) {\n    if (_.isString(value)) {\n      return parseFloat(value.replace( /\\D+$/g, ''));\n    }\n    else {\n      return value * 1.0;\n    }\n  }\n\n  // Gets the position on the opposite side of a Hex\n  function oppositePosition(position) {\n    return (position + 3 > 5) ? position - 3 : position + 3;\n  }\n\n  // This assumes that hexList is ordered by distance.\n  function getHexesAtDistance(distance, hexList) {\n    var first = null,\n        last;\n    _.each(hexList, function (hex, index) {\n      if (_.isNull(first) && hex.options.distance == distance) {\n        first = index;\n      }\n      if (_.isNull(last) && !_.isNull(first) && hex.options.distance > distance) {\n        last = index;\n      }\n    });\n\n    return hexList.slice(first, last);\n  }\n\n  // Current version of the library. Keep in sync with `package.json`.\n  Hexer.VERSION = '0.0.1';\n\n  return Hexer;\n}));"],"sourceRoot":"/source/"}