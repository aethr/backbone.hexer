{"version":3,"sources":["backbone.hexer.js"],"names":["root","factory","define","amd","_","Backbone","$","exports","Hexer","require","e","jQuery","Zepto","ender","this","parseFloatIfString","value","isString","parseFloat","replace","oppositePosition","position","getHexesAtDistance","distance","hexList","last","first","each","hex","index","isNull","options","slice","HexGridView","View","extend","tagName","className","defaults","depth","color","size","spacing","center","x","y","events","hexes","animateTimeout","initialize","unit","bindAll","createHexViews","render","i","fillDepth","addHex","allEdgeHexes","addAdjacentHexes","bind","newHex","Hex","push","$el","append","addAdjacentHex","originHex","hexParams","angle","Math","PI","scale","cos","sin","originPosition","neighbors","addNeighbor","prevPosition","nextPosition","has","startPosition","count","isUndefined","animate","params","animateFunction","order","delay","animateHelper","length","setTimeout","content","isFunction","cssProps","transform","webkitTransform","width","sqrt","height","background","css","html","call","exchange","VERSION"],"mappings":"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","file":"backbone.hexer.min.js","sourcesContent":["// backbone.hexer.js 0.1\n// (c) 2015 Lindsay Gaines\n\n// backbone.hexer may be freely distributed under the MIT license.\n// For all details and documentation:\n// http://github.com/aethr/backbone.hexer\n\n(function(root, factory) {\n  // Set up depending on the environment. Start with AMD.\n  if (typeof define === 'function' && define.amd) {\n    define(['underscore', 'backbone', 'jquery', 'exports'], function(_, Backbone, $, exports) {\n      // Export global even in AMD case in case this script is loaded with\n      // others that may still expect a global Backbone.\n      Backbone.Hexer = factory(root, exports, _, Backbone, $);\n    });\n\n  // Next for Node.js or CommonJS. jQuery may not be needed as a module.\n  } else if (typeof exports !== 'undefined') {\n    var _ = require('underscore'), Backbone = require('backbone'), $;\n    try { $ = require('jquery'); } catch(e) {}\n\n    factory(root, exports, _, Backbone, $);\n\n  // Finally, as a browser global.\n  } else {\n    root.Backbone.Hexer = factory(root, {}, root._, root.Backbone, (root.jQuery || root.Zepto || root.ender || root.$));\n  }\n}(this, function(root, Hexer, _, Backbone, $) {\n\n  // a Hexer is a Backbone View\n  Hexer = Backbone.Hexer = Backbone.HexGridView = Backbone.View.extend({\n\n    tagName: \"div\",\n    className: \"bbh-container\",\n\n    defaults: {\n      depth: 2,\n      color: '#999999',\n      size: '6em',\n      spacing: '0.5em',\n      center: {x: 0, y: 0}\n    },\n\n    events: {},\n\n    hexes: [],\n\n    animateTimeout: null,\n\n    initialize: function(options) {\n      // Default options\n      this.options = _.extend({}, this.defaults, options);\n\n      // Split convenient notations (ie '5em') into their value and unit\n      this.options.unit     = this.options.size.replace( /^\\d+/g, '');\n      if (this.options.unit == '') this.options.unit = 'em'; // Default to em\n      // Parse the numeric values into floats\n      this.options.size     = parseFloatIfString(this.options.size);\n      this.options.spacing  = parseFloatIfString(this.options.spacing);\n      this.options.center.x = parseFloatIfString(this.options.center.x);\n      this.options.center.y = parseFloatIfString(this.options.center.y);\n\n      _.bindAll(this, 'addAdjacentHexes');\n\n      // Create all the Hexes\n      this.createHexViews();\n    },\n\n    render: function() {\n      // Allow each hex to re-render if necessary\n      _.each(this.hexes, function (hex, i) {\n        hex.render();\n      });\n      return this;\n    },\n\n    /**\n     * Create the individual Hexes that will comrprise the grid.\n     */\n    createHexViews: function() {\n      var fillDepth = (this.options.depth == 'fill') ? 10 : this.options.depth;\n\n      for (var i = 0; i < fillDepth; i++) {\n        switch (i) {\n          // No Hexes have been created yet, make the first\n          case 0:\n            this.addHex({\n              distance: 0,\n              x: this.options.center.x,\n              y: this.options.center.y\n            });\n            break;\n\n          // Find every Hex at the current depth and add Hexes around it!\n          default:\n            // This is complicated!\n            var allEdgeHexes = getHexesAtDistance(i - 1, this.hexes);\n            _.each(allEdgeHexes, function (hex, index) {\n              this.addAdjacentHexes(hex, 0, 6);\n            }.bind(this));\n            break;\n        }\n      }\n    },\n\n    /**\n     * Helper function to create a single Hex with the specified options, and\n     * add its el to the DOM.\n     *\n     * @param options\n     *   Parameters to pass to the constructor of the new Hex\n     * @returns {Hex}\n     */\n    addHex: function(options) {\n      options = _.extend({\n          size: this.options.size + this.options.unit,\n          color: this.options.color\n      }, options);\n      var newHex = new Hex(options);\n      this.hexes.push(newHex);\n      this.$el.append(newHex.$el);\n\n      return newHex;\n    },\n\n    /**\n     * Add a single adjacent hex to the origin hex, at one of the edges\n     * specified by the position.\n     *\n     * @param originHex\n     *   The Hex that will have new Hexes added around its edges.\n     * @param position\n     *   The position of the edge where the new hex should be drawn\n     *    0\n     * 5 / \\ 1\n     * 4 \\_/ 2\n     *    3\n     * @param hexParams\n     *   The options to be passed to the new Hex\n     */\n    addAdjacentHex: function (originHex, position, hexParams) {\n      // Calculate the angle between the originHex and the new adjacent Hex\n      var angle = (position == 0) ? 0 : (2.0 * Math.PI / 6) * position,\n\n          // Distance of the new Hex from the originHex\n          scale = this.options.size + this.options.spacing,\n\n          // Position of the new Hex\n          x = originHex.options.x + (Math.cos(angle) * scale),\n          y = originHex.options.y + (Math.sin(angle) * scale),\n\n          // Store the distance from the original Hex\n          distance = originHex.options.distance + 1,\n\n          // Keep a reference to the originHex\n          originPosition = oppositePosition(position),\n          neighbors = {};\n\n      // Since they are adjacent, the originHex will occupy the opposite edge\n      neighbors[originPosition] = originHex;\n\n      // Add a new Hex with the supplied parameters, at the new coordinates\n      var newHex = this.addHex(_.extend({\n        x: x,\n        y: y,\n        distance: distance,\n        neighbors: neighbors\n      }, hexParams));\n\n      // Store a reference to the originHex's new neighbor\n      originHex.addNeighbor(position, newHex, true);\n\n      // If the originHex has neighbors adjacent to the new Hex, pass the\n      // references so the Hex grid has a more complete set of relationships\n      var prevPosition = (position - 1 >= 0) ? position - 1 : position + 5,\n          nextPosition = (position + 1 < 6)  ? position + 1 : position - 5;\n      if (_.has(originHex.options.neighbors, prevPosition)) {\n        newHex.addNeighbor(prevPosition - 1, originHex.options.neighbors[prevPosition], true);\n      }\n      if (_.has(originHex.options.neighbors, nextPosition)) {\n        newHex.addNeighbor(nextPosition + 1, originHex.options.neighbors[nextPosition], true);\n      }\n    },\n\n    /**\n     * Add new Hexes adjacent to the originHex, starting at the specified\n     * startPosition.  Any positions that are already filled with a Hex will\n     * be skipped.\n     *\n     * @param originHex\n     *   The Hex to add adjacent Hexes to.\n     * @param startPosition\n     *   The position of the edge where the first Hex should be added.\n     * @param count\n     *   The number of Hexes to be added.\n     */\n    addAdjacentHexes: function(originHex, startPosition, count) {\n      // Reset values back within legal bounds\n      if (count > 6)\n        count = 6;\n      if (startPosition > 5) {\n        startPosition -= 6;\n      }\n      // Add a new Hex for each edge until we reach the supplied count\n      for (var i = startPosition; i < startPosition + count; i++) {\n        // Don't try to add a new Hex where there is one already\n        if (!_.isUndefined(originHex.options.neighbors[i]) && !_.isNull(originHex.options.neighbors[i])) {\n          continue;\n        }\n\n        // Add the new Hex\n        this.addAdjacentHex(originHex, i, {\n          // Just an example, print the hex number inside each hex\n//          content: _.partial(function(count) { return count; }, this.hexes.length)\n        });\n      }\n    },\n\n    /**\n     * A function that allows an animation to be run across a set of Hexes.\n     *\n     * @param options\n     *   An object which specifies how to animate the Hexes.  Valid keys are:\n     *   order: an array of Hexes, in the order you want to animate them.\n     *   animateFunction: a function with a single argument for a Hex.  This\n     *     function will be called once on each Hex provided in order.\n     *   delay: the number of ms to delay in between animating each Hex.\n     */\n    animate: function(options) {\n      // Set some sane defaults for the animation\n      var params = _.extend({\n        animateFunction: function(hex) { /* Do something! */ },\n        order: this.hexes,\n        delay: 50\n      }, options);\n\n      // Create a helper function that will help us execute a single animation\n      // and then set a timeout for the next animation\n      var animateHelper = function (hexList, index, animateFunction, delay) {\n        // Execute the animation on the current Hex\n        animateFunction(hexList[index]);\n\n        // If we haven't gotten to the end of the list, set a timer for the\n        // next animation to occur\n        if (index + 1 < hexList.length) {\n          // Store a reference to the timeout in case we want to end early\n          this.animateTimeout = setTimeout(function() {\n            animateHelper(hexList, index + 1, animateFunction, delay);\n          }, params.delay);\n        }\n      }\n\n      // Kick off the first animation straight away\n      animateHelper(params.order, 0, params.animateFunction, params.delay);\n    }\n\n  });\n\n  // a Hexer is a Backbone View\n  var Hex = Backbone.View.extend({\n    tagName: \"div\",\n    className: \"bbh-hex\",\n\n    defaults: {\n      x: 0, y: 0,\n      size: '3em',\n      color: '#999999',\n      content: '',\n      neighbors: {}\n    },\n\n    neighbors: {},\n\n    initialize: function(options) {\n      // Default options\n      this.options = _.extend({}, this.defaults, options);\n\n      this.options.unit = this.options.size.replace( /^\\d+/g, '');\n      this.options.size = parseFloatIfString(this.options.size);\n\n      // Allow content to be defined by a function, simply replace the\n      // default function, which just returns this.options.content\n      if (_.isFunction(this.options.content)) {\n        this.content = this.options.content;\n      }\n    },\n\n    render: function() {\n      var cssProps = {\n        transform: 'translateX(' + this.options.x + this.options.unit + ') translateY(' + this.options.y + this.options.unit + ')',\n        webkitTransform: 'translateX(' + this.options.x + this.options.unit + ' translateY(' + this.options.y + this.options.unit + ')',\n        width:  (Math.sqrt(3)/2 * this.options.size) + this.options.unit, // width is smaller than height\n        height: this.options.size + this.options.unit\n      }\n\n      if (_.isNull(this.options.color)) {\n        cssProps.background = this.options.color;\n      }\n\n      // Set the css properties of the Hex to display in the right place\n      this.$el.css(cssProps);\n\n      // Set the inner content of the Hex if available\n      this.$el.html('<div class=\"content\"><span>' + this.content.call(this) + '</span></div>');\n\n      return this;\n    },\n\n    /**\n     * Default content function, just returns the content string.\n     * @returns string\n     */\n    content: function() {\n      return this.options.content;\n    },\n\n    /**\n     * Add a reference to a neighboring Hex.\n     * @param position\n     *   The position of the neighbor.\n     * @param hex\n     *   The reference to the neighbor Hex.\n     * @param exchange\n     *   If true, a reference to this Hex will be passed to the neighboring Hex.\n     */\n    addNeighbor: function(position, hex, exchange) {\n      exchange = (!_.isUndefined(exchange)) ? exchange : false;\n\n      // Normalise position\n      position = (position > 5) ? position - 6 : position;\n      position = (position < 0) ? position + 6 : position;\n\n      // Store a reference at the specified position to the new neighbor\n      this.options.neighbors[position] = hex;\n\n      // If Hexes are exchanging neighbors, tell the neighbor to store a\n      // reference to this Hex in the opposite position\n      if (exchange === true) {\n        // For the neighbor Hex, this will occupy the opposite position\n        hex.addNeighbor(oppositePosition(position), this, false);\n      }\n    }\n\n  });\n\n\n  /**\n   * Privately scoped helper functions\n   */\n\n  // Remove CSS units (eg, 'px') and return the numeric value as a float\n  function parseFloatIfString(value) {\n    if (_.isString(value)) {\n      return parseFloat(value.replace( /\\D+$/g, ''));\n    }\n    else {\n      return value * 1.0;\n    }\n  }\n\n  // Gets the position on the opposite side of a Hex\n  function oppositePosition(position) {\n    return (position + 3 > 5) ? position - 3 : position + 3;\n  }\n\n  // This assumes that hexList is ordered by distance.\n  function getHexesAtDistance(distance, hexList) {\n    var first = null,\n        last;\n    _.each(hexList, function (hex, index) {\n      if (_.isNull(first) && hex.options.distance == distance) {\n        first = index;\n      }\n      if (_.isNull(last) && !_.isNull(first) && hex.options.distance > distance) {\n        last = index;\n      }\n    });\n\n    return hexList.slice(first, last);\n  }\n\n  // Current version of the library. Keep in sync with `package.json`.\n  Hexer.VERSION = '0.0.1';\n\n  return Hexer;\n}));"],"sourceRoot":"/source/"}