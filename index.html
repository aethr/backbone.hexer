<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title></title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Backbone.hexer</title>
    <link rel="stylesheet" href="./style.css">
    <link rel="stylesheet" href="https://rawgit.com/aethr/backbone.hexer/be7a8f8ae2de9d1c5567f04d3f64f5f6a0290fbc/backbone.hexer.css">
    <style type="text/css" media="screen">
.hex {

}
    </style>


</head>
<body>
    <h1>backbone.hexer</h1>
    <div id="examples">
        <div class="example-container">
            <div id="example-1" class="example"></div>
            <div class="example-code">
                <h2>Example 1</h2>
                <p>code example</p>
            </div>
        </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.1/jquery.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/backbone.js/1.3.2/backbone-min.js"></script>
    <script src="https://rawgit.com/aethr/backbone.hexer/be7a8f8ae2de9d1c5567f04d3f64f5f6a0290fbc/backbone.hexer.js"></script>

    <script type="text/javascript">
        (function($) {
            $(function() {
                // Construct a hex grid 4 deep, with the centre near 12x12em
                window.myHex = new Backbone.Hexer({
                    el: '#example-1',
                    depth: 3,
                    size: '4em',
                    spacing: 0,
                    center: {x: '12em', y: '12em'}
                });
                // Render all the Hexes as HTML elements
                myHex.render();
                // Animate the Hexes
                myHex.animate({
                    // How do we want each individual Hex to be altered during
                    // animate?
                    animateFunction: function(hex) {
                        // Reset the hex to styles based on its internal
                        // properties
                        hex.render();
                        // Transform is used to move the hexes to their x/y
                        // position, so instead of replacing it, lets add to it
                        var transform = hex.$el.css('transform');
                        hex.$el.css({
                            opacity: '1',
                            transform: transform + ' rotate(120deg)'
                        });
                    },
                    // In what order should the Hexes be animated
//                    animateQueue: splitByDistance(myHex.hexes),
                    animateQueue: spiralWalk(myHex.hexes),
                    // How long to delay between animation actions
                    delay: 150
                });
            });
            /**
             * Given an array of Hexes, split them into multiple arrays,
             * grouped by their distance property.
             * @param hexList
             *   The list of Hexes to split
             * @returns {Array}
             *   An array of arrays, with each sub-array containing Hexes of
             *   equal distance.
             */
            function splitByDistance(hexes) {
                // Determine an animation order and animate
                var localHexes = _.clone(hexes),
                        animateQueue = [],
                        currentDistance = 0;
                // Keep adding Hexes until there are none left to add
                while (localHexes.length > 0) {
                    // Collect all the Hexes at the current distance
                    var hexGroup = [];
                    for (var i = 0; i < localHexes.length; i++) {
                        if (localHexes[i].options.distance == currentDistance) {
                            // Place the current Hex in the array with others
                            // of the same distance
                            hexGroup.push(localHexes[i]);
                            // Remove the Hex from the local array so it won't
                            // be processed twice
                            localHexes.splice(i, 1);
                            i--; // We are modifying the list during traversal!
                        }
                    }
                    // Add the array of Hexes at this distance to the result
                    animateQueue.push(hexGroup);
                    currentDistance++;
                }
                return animateQueue;
            }
            function spiralOrder(hexes) {
                // Determine an animation order and animate
                var localHexes   = _.clone(hexes);
                // Add a 'weight' property to each Hex
                localHexes[0].weight = 0;
                for (var i = 1; i < localHexes.length; i++) {
                    var hex       = localHexes[i],
                            neighbors = localHexes[i].options.neighbors,
                            edges     = Object.keys(neighbors),
                            closestEdge = null;
                    // Find the neighbor hex with the lowest defined weight
                    for (var e = 0; e < edges.length; e++) {
                        var neighbor = neighbors[edges[e]];
                        // If the neighbor being examined hasn't had a weight
                        // set, it is useless to us at the moment!
                        if (_.isUndefined(neighbor.weight)) {
                            continue;
                        }
                        // If closestEdge is unset, of closer than the current
                        // edge, replace it
                        if (_.isNull(closestEdge)
                                || (!_.isUndefined(hex.options.neighbors[closestEdge].weight) && neighbor.weight < hex.options.neighbors[closestEdge].weight)) {
                            closestEdge = edges[e];
                        }
                    }
                    var edgeFromNeighbor = (parseInt(closestEdge) + 3 > 5) ? parseInt(closestEdge) - 3 : parseInt(closestEdge) + 3,
                            edgeWeight       = 1 + parseInt(edgeFromNeighbor);
                    hex.weight = (hex.options.neighbors[closestEdge].weight * 6) + edgeWeight;
                }
                // Sort by the computed weight
                localHexes.sort(function(a,b) {return a.weight - b.weight});
                // Place each element in a separate array so that the animation
                // occurs one hex at a time
                return localHexes.map(function(currentValue, index, array) { return [currentValue]; });
            }
            function spiralWalk(hexes) {
                // Determine an animation order and animate
                var localHexes     = _.clone(hexes),
                        startHex       = localHexes.shift(),
                        currentHex     = startHex,
                        direction      = 1,
                        edgeCounter    = 0,
                        animationQueue = [];
                while (localHexes.length) {
                    // Add the current hex to the animation queue
                    animationQueue.push([currentHex]);
                    localHexes.splice(localHexes.indexOf(currentHex), 1);
                    // Find the next Hex in the sequence
                    if (edgeCounter > 0) {
                        currentHex = currentHex.options.neighbors[direction];
                        edgeCounter--;
                    } else {
                        // If the last direction was 0, we've reached the end
                        // of a full circuit
                        if (direction == 1) {
                            if (_.isUndefined(startHex.options.neighbors[0])) {
                                // We have reached the end of the outer ring
                                break;
                            }
                            // Advance to the next ring outwards, resetting
                            // walk values
                            currentHex  = startHex.options.neighbors[0];
                            startHex    = currentHex;
                            direction   = 2;
                            edgeCounter = currentHex.options.distance - 1;
                        } else {
                            currentHex = currentHex.options.neighbors[direction];
                            direction = (direction == 5) ? 0 : direction + 1;
                            edgeCounter = currentHex.options.distance - 1;
                        }
                    }
                }
                animationQueue.push([currentHex]);
                return animationQueue;
            }
        })(jQuery);
    </script>
</body>
</html>
